<html>
  <head>
    <title>Lancelot Naming Bug Report</title>
  </head>

  <style>
body { 
    font: 11px/1.5em Verdana, sans-serif; 
}  

#page { 
    width: 920px;
}

.classReport {
    float: left;
    border: 1px solid grey;
    margin-bottom: 50px;
}

.methodBugReport {
    clear: both;
    width: 900px;
    margin-bottom: 10px;
    padding: 10px;
}

.methodBugReport .violations {
    float: left;
    list-style: none;
    margin: 0;
    padding: 0;
    width: 420px;
}

.methodBugReport code {
    float: left;
    width: 420px;
    overflow:hidden;
}
  </style>

  <body>
    <div id="page">

  <div class="classReport">
    <h2>AnalysisCacheToRepositoryAdapter in package edu/umd/cs/findbugs</h2>
    <div class="methodBugReport">
      <ul class="violations">
        <li>
        RETURN_TYPE_IN_NAME - OFF - INAPPROPRIATE
        </li>
      </ul>
      <pre><code>
public JavaClass loadClass(String className) throws ClassNotFoundException {
    if (className.length() == 0) throw new IllegalArgumentException("Request to load empty class");
    className = ClassName.toSlashedClassName(className);
    ClassDescriptor classDescriptor = DescriptorFactory.instance().getClassDescriptor(className);
    try {
        return Global.getAnalysisCache().getClassAnalysis(JavaClass.class, classDescriptor);
    } catch (CheckedAnalysisException e) {
        throw new ClassNotFoundException("Exception while looking for class " + className, e);
    }
}
      </pre></code>
    </div>
  </div>
  <div class="classReport">
    <h2>Analyze in package edu/umd/cs/findbugs</h2>
    <div class="methodBugReport">
      <ul class="violations">
        <li>
        RETURNS_BOOLEAN - OFF - NOTIFY
        </li>
      </ul>
      <pre><code>
public static double isDeepSerializable(String refSig) throws ClassNotFoundException {
    if (storedException != null) throw storedException;
    if (isPrimitiveComponentClass(refSig)) return 1.0;
    String refName = getComponentClass(refSig);
    if (refName.equals("java.lang.Object")) return 0.99;
    JavaClass refJavaClass = Repository.lookupClass(refName);
    return isDeepSerializable(refJavaClass);
}
      </pre></code>
    </div>
    <div class="methodBugReport">
      <ul class="violations">
        <li>
        RETURNS_BOOLEAN - OFF - INAPPROPRIATE
        </li>
      </ul>
      <pre><code>
public static double isDeepRemote(String refSig) {
    if (remote == null) return 0.1;
    String refName = getComponentClass(refSig);
    if (refName.equals("java.lang.Object")) return 0.99;
    JavaClass refJavaClass;
    try {
        refJavaClass = Repository.lookupClass(refName);
        return deepInstanceOf(refJavaClass, remote);
    } catch (ClassNotFoundException e) {
        return 0.99;
    }
}
      </pre></code>
    </div>
    <div class="methodBugReport">
      <ul class="violations">
        <li>
        RETURNS_BOOLEAN - OFF - NOTIFY
        </li>
      </ul>
      <pre><code>
public static double isDeepSerializable(JavaClass x) throws ClassNotFoundException {
    if (storedException != null) throw storedException;
    double result = deepInstanceOf(x, serializable);
    if (result >= 0.9) return result;
    result = Math.max(result, deepInstanceOf(x, collection));
    if (result >= 0.9) return result;
    result = Math.max(result, deepInstanceOf(x, map));
    if (result >= 0.9) return result;
    result = Math.max(result, 0.5 * deepInstanceOf(x, comparator));
    if (result >= 0.9) return result;
    return result;
}
      </pre></code>
    </div>
  </div>
  <div class="classReport">
    <h2>BugInstance$BugPropertyIterator in package edu/umd/cs/findbugs</h2>
    <div class="methodBugReport">
      <ul class="violations">
        <li>
        FIELD_READER - OFF - NOTIFY
        </li>
      </ul>
      <pre><code>

      </pre></code>
    </div>
  </div>
  <div class="classReport">
    <h2>BugInstance in package edu/umd/cs/findbugs</h2>
    <div class="methodBugReport">
      <ul class="violations">
        <li>
        RETURN_TYPE_IN_NAME - ON - NOTIFY
        </li>
      </ul>
      <pre><code>
/**
	 * Get a string describing the bug priority and type.
	 * e.g. "High Priority Correctness"
	 * @return a string describing the bug priority and type
	 */
public String getPriorityTypeString() {
    String priorityString = getPriorityString();
    BugPattern bugPattern = this.getBugPattern();
    String categoryString;
    if (bugPattern == null) categoryString = "Unknown category for " + getType(); else categoryString = I18N.instance().getBugCategoryDescription(bugPattern.getCategory());
    return priorityString + " Priority " + categoryString;
}
      </pre></code>
    </div>
    <div class="methodBugReport">
      <ul class="violations">
        <li>
        RETURN_TYPE_IN_NAME - ON - NOTIFY
        </li>
      </ul>
      <pre><code>
public String getPriorityString() {
    int value = this.getPriority();
    String priorityString;
    if (value == Detector.HIGH_PRIORITY) priorityString = edu.umd.cs.findbugs.L10N.getLocalString("sort.priority_high", "High"); else if (value == Detector.NORMAL_PRIORITY) priorityString = edu.umd.cs.findbugs.L10N.getLocalString("sort.priority_normal", "Medium"); else if (value == Detector.LOW_PRIORITY) priorityString = edu.umd.cs.findbugs.L10N.getLocalString("sort.priority_low", "Low"); else if (value == Detector.EXP_PRIORITY) priorityString = edu.umd.cs.findbugs.L10N.getLocalString("sort.priority_experimental", "Experimental"); else priorityString = edu.umd.cs.findbugs.L10N.getLocalString("sort.priority_ignore", "Ignore");
    return priorityString;
}
      </pre></code>
    </div>
    <div class="methodBugReport">
      <ul class="violations">
        <li>
        CONTAINS_LOOP - ON - NOTIFY
        </li>
      </ul>
      <pre><code>
private String getInstanceKeyOld() {
    StringBuilder buf = new StringBuilder(type);
    for (BugAnnotation annotation : annotationList) {
        if (annotation instanceof SourceLineAnnotation || annotation instanceof MethodAnnotation && !annotation.isSignificant()) {
        } else {
            buf.append(":");
            buf.append(annotation.format("hash", null));
        }
    }
    return buf.toString();
}
      </pre></code>
    </div>
    <div class="methodBugReport">
      <ul class="violations">
        <li>
        CONTAINS_LOOP - ON - NOTIFY
        </li>
      </ul>
      <pre><code>
private String getInstanceKeyNew() {
    StringBuilder buf = new StringBuilder(type);
    for (BugAnnotation annotation : annotationList) if (annotation.isSignificant() || annotation instanceof IntAnnotation || annotation instanceof LocalVariableAnnotation) {
        buf.append(":");
        buf.append(annotation.format("hash", null));
    }
    return buf.toString();
}
      </pre></code>
    </div>
    <div class="methodBugReport">
      <ul class="violations">
        <li>
        TYPE_MANIPULATOR - ON - NOTIFY
        </li>
      </ul>
      <pre><code>
@Override
public int hashCode() {
    if (cachedHashCode == INVALID_HASH_CODE) {
        int hashcode = type.hashCode() + priority;
        Iterator<BugAnnotation> i = annotationIterator();
        while (i.hasNext()) hashcode += i.next().hashCode();
        if (hashcode == INVALID_HASH_CODE) hashcode = INVALID_HASH_CODE + 1;
        cachedHashCode = hashcode;
    }
    return cachedHashCode;
}
      </pre></code>
    </div>
  </div>
  <div class="classReport">
    <h2>DeepSubtypeAnalysis in package edu/umd/cs/findbugs</h2>
    <div class="methodBugReport">
      <ul class="violations">
        <li>
        RETURNS_BOOLEAN - OFF - NOTIFY
        </li>
      </ul>
      <pre><code>
public static double isDeepSerializable(@DottedClassName String refSig) throws ClassNotFoundException {
    if (storedException != null) throw storedException;
    if (isPrimitiveComponentClass(refSig)) {
        if (DEBUG) {
            System.out.println("regSig \"" + refSig + "\" is primitive component class");
        }
        return 1.0;
    }
    String refName = getComponentClass(refSig);
    if (refName.equals("java.lang.Object")) return 0.99;
    JavaClass refJavaClass = Repository.lookupClass(refName);
    return isDeepSerializable(refJavaClass);
}
      </pre></code>
    </div>
    <div class="methodBugReport">
      <ul class="violations">
        <li>
        RETURNS_BOOLEAN - OFF - INAPPROPRIATE
        </li>
      </ul>
      <pre><code>
public static double isDeepRemote(String refSig) {
    if (remote == null) return 0.1;
    String refName = getComponentClass(refSig);
    if (refName.equals("java.lang.Object")) return 0.99;
    JavaClass refJavaClass;
    try {
        refJavaClass = Repository.lookupClass(refName);
        return Analyze.deepInstanceOf(refJavaClass, remote);
    } catch (ClassNotFoundException e) {
        return 0.99;
    }
}
      </pre></code>
    </div>
    <div class="methodBugReport">
      <ul class="violations">
        <li>
        RETURNS_BOOLEAN - OFF - NOTIFY
        </li>
      </ul>
      <pre><code>
public static double isDeepSerializable(JavaClass x) throws ClassNotFoundException {
    if (storedException != null) throw storedException;
    if (x.getClassName().equals("java.lang.Object")) return 0.4;
    double result = Analyze.deepInstanceOf(x, serializable);
    if (result >= 0.9) {
        if (DEBUG) {
            System.out.println("High serializable result: " + result);
        }
        return result;
    }
    if (x.isFinal()) return result;
    ClassDescriptor classDescriptor = DescriptorFactory.createClassDescriptor(x);
    Subtypes2 subtypes2 = AnalysisContext.currentAnalysisContext().getSubtypes2();
    double confidence = 0.6;
    Set<ClassDescriptor> directSubtypes = subtypes2.getDirectSubtypes(classDescriptor);
    directSubtypes.remove(classDescriptor);
    if (x.isAbstract() || x.isInterface()) {
        confidence = 0.8;
        result = Math.max(result, 0.4);
    } else if (directSubtypes.isEmpty()) confidence = 0.2;
    for (ClassDescriptor subtype : directSubtypes) {
        JavaClass subJavaClass = Repository.lookupClass(subtype.getDottedClassName());
        result = Math.max(result, confidence * isDeepSerializable(subJavaClass));
    }
    if (result >= 0.9) {
        return result;
    }
    result = Math.max(result, confidence * Analyze.deepInstanceOf(x, collection));
    if (result >= 0.9) {
        if (DEBUG) {
            System.out.println("High collection result: " + result);
        }
        return result;
    }
    result = Math.max(result, confidence * Analyze.deepInstanceOf(x, map));
    if (result >= 0.9) {
        if (DEBUG) {
            System.out.println("High map result: " + result);
        }
        return result;
    }
    result = Math.max(result, confidence * 0.5 * Analyze.deepInstanceOf(x, comparator));
    if (result >= 0.9) {
        if (DEBUG) {
            System.out.println("High comparator result: " + result);
        }
        return result;
    }
    if (DEBUG) {
        System.out.println("No high results; max: " + result);
    }
    return result;
}
      </pre></code>
    </div>
  </div>
  <div class="classReport">
    <h2>DetectorFactory in package edu/umd/cs/findbugs</h2>
    <div class="methodBugReport">
      <ul class="violations">
        <li>
        PARAMETER_TYPE_IN_NAME - ON - INAPPROPRIATE
        </li>
      </ul>
      <pre><code>
/**
	 * Determine whether the detector class is a subtype of the given class (or interface).
	 * 
	 * @param otherClass a class or interface
	 * @return true if the detector class is a subtype of the given class or interface
	 */
public boolean isDetectorClassSubtypeOf(Class<?> otherClass) {
    return otherClass.isAssignableFrom(detectorCreator.getDetectorClass());
}
      </pre></code>
    </div>
    <div class="methodBugReport">
      <ul class="violations">
        <li>
        CREATES_CUSTOM_OBJECTS - ON - INAPPROPRIATE
        </li>
        <li>
        CREATES_STRING_OBJECTS - ON - INAPPROPRIATE
        </li>
        <li>
        CREATES_REGULAR_OBJECTS - ON - INAPPROPRIATE
        </li>
      </ul>
      <pre><code>
/**
	 * Check to see if we are running on a recent-enough JRE for
	 * this detector to be enabled.
	 * 
	 * @return true if the current JRE is recent enough to run the Detector,
	 *         false if it is too old
	 */
public boolean isEnabledForCurrentJRE() {
    if (requireJRE.equals("")) return true;
    try {
        JavaVersion requiredVersion = new JavaVersion(requireJRE);
        JavaVersion runtimeVersion = JavaVersion.getRuntimeVersion();
        if (DEBUG_JAVA_VERSION) {
            System.out.println("Checking JRE version for " + getShortName() + " (requires " + requiredVersion + ", running on " + runtimeVersion + ")");
        }
        boolean enabledForCurrentJRE = runtimeVersion.isSameOrNewerThan(requiredVersion);
        if (DEBUG_JAVA_VERSION) {
            System.out.println("\t==> " + enabledForCurrentJRE);
        }
        return enabledForCurrentJRE;
    } catch (JavaVersionException e) {
        if (DEBUG_JAVA_VERSION) {
            System.out.println("Couldn't check Java version: " + e.toString());
            e.printStackTrace(System.out);
        }
        return false;
    }
}
      </pre></code>
    </div>
  </div>
  <div class="classReport">
    <h2>FieldAnnotation in package edu/umd/cs/findbugs</h2>
    <div class="methodBugReport">
      <ul class="violations">
        <li>
        RETURNS_BOOLEAN - OFF - NOTIFY
        </li>
        <li>
        RETURNS_REFERENCE - ON - NOTIFY
        </li>
        <li>
        RETURNS_CREATED_OBJECT - ON - INAPPROPRIATE
        </li>
        <li>
        CREATES_OWN_CLASS_OBJECTS - ON - FORBIDDEN
        </li>
      </ul>
      <pre><code>
/**
	 * Is the given instruction a read of a field?
	 *
	 * @param ins the Instruction to check
	 * @param cpg ConstantPoolGen of the method containing the instruction
	 * @return the Field if the instruction is a read of a field, null otherwise
	 */
public static FieldAnnotation isRead(Instruction ins, ConstantPoolGen cpg) {
    if (ins instanceof GETFIELD || ins instanceof GETSTATIC) {
        FieldInstruction fins = (FieldInstruction) ins;
        String className = fins.getClassName(cpg);
        return new FieldAnnotation(className, fins.getName(cpg), fins.getSignature(cpg), fins instanceof GETSTATIC);
    } else return null;
}
      </pre></code>
    </div>
    <div class="methodBugReport">
      <ul class="violations">
        <li>
        RETURNS_CREATED_OBJECT - ON - FORBIDDEN
        </li>
        <li>
        RETURNS_BOOLEAN - OFF - INAPPROPRIATE
        </li>
        <li>
        CREATES_OWN_CLASS_OBJECTS - ON - FORBIDDEN
        </li>
      </ul>
      <pre><code>
/**
	 * Is the instruction a write of a field?
	 *
	 * @param ins the Instruction to check
	 * @param cpg ConstantPoolGen of the method containing the instruction
	 * @return the Field if instruction is a write of a field, null otherwise
	 */
public static FieldAnnotation isWrite(Instruction ins, ConstantPoolGen cpg) {
    if (ins instanceof PUTFIELD || ins instanceof PUTSTATIC) {
        FieldInstruction fins = (FieldInstruction) ins;
        String className = fins.getClassName(cpg);
        return new FieldAnnotation(className, fins.getName(cpg), fins.getSignature(cpg), fins instanceof PUTSTATIC);
    } else return null;
}
      </pre></code>
    </div>
  </div>
  <div class="classReport">
    <h2>FuzzyBugComparator in package edu/umd/cs/findbugs</h2>
    <div class="methodBugReport">
      <ul class="violations">
        <li>
        CREATES_CUSTOM_OBJECTS - ON - NOTIFY
        </li>
      </ul>
      <pre><code>
public int compare(BugInstance lhs, BugInstance rhs) {
    int cmp;
    if (DEBUG) System.out.println("Fuzzy comparison");
    BugPattern lhsPattern = lhs.getBugPattern();
    BugPattern rhsPattern = rhs.getBugPattern();
    if (lhsPattern == null || rhsPattern == null) {
        if (DEBUG) {
            if (lhsPattern == null) System.out.println("Missing pattern: " + lhs.getType());
            if (rhsPattern == null) System.out.println("Missing pattern: " + rhs.getType());
        }
        String lhsCode = getCode(lhs.getType());
        String rhsCode = getCode(rhs.getType());
        if ((cmp = lhsCode.compareTo(rhsCode)) != 0) return cmp;
    } else {
        if ((cmp = lhsPattern.getAbbrev().compareTo(rhsPattern.getAbbrev())) != 0) return cmp;
    }
    BugCollection lhsCollection = bugCollectionMap.get(lhs);
    BugCollection rhsCollection = bugCollectionMap.get(rhs);
    Iterator<BugAnnotation> lhsIter = new FilteringBugAnnotationIterator(lhs.annotationIterator());
    Iterator<BugAnnotation> rhsIter = new FilteringBugAnnotationIterator(rhs.annotationIterator());
    while (lhsIter.hasNext() && rhsIter.hasNext()) {
        BugAnnotation lhsAnnotation = lhsIter.next();
        BugAnnotation rhsAnnotation = rhsIter.next();
        if (DEBUG) System.out.println("Compare annotations: " + lhsAnnotation + "," + rhsAnnotation);
        cmp = lhsAnnotation.getClass().getName().compareTo(rhsAnnotation.getClass().getName());
        if (cmp != 0) {
            if (DEBUG) System.out.println("annotation class mismatch: " + lhsAnnotation.getClass().getName() + "," + rhsAnnotation.getClass().getName());
            return cmp;
        }
        if (lhsAnnotation.getClass() == ClassAnnotation.class) cmp = compareClasses(lhsCollection, rhsCollection, (ClassAnnotation) lhsAnnotation, (ClassAnnotation) rhsAnnotation); else if (lhsAnnotation.getClass() == MethodAnnotation.class) cmp = compareMethods(lhsCollection, rhsCollection, (MethodAnnotation) lhsAnnotation, (MethodAnnotation) rhsAnnotation); else if (lhsAnnotation.getClass() == SourceLineAnnotation.class) cmp = compareSourceLines(lhsCollection, rhsCollection, (SourceLineAnnotation) lhsAnnotation, (SourceLineAnnotation) rhsAnnotation); else cmp = lhsAnnotation.compareTo(rhsAnnotation);
        if (cmp != 0) return cmp;
    }
    if (!lhsIter.hasNext() && !rhsIter.hasNext()) {
        if (DEBUG) System.out.println("Match!");
        return 0;
    } else return (lhsIter.hasNext() ? 1 : -1);
}
      </pre></code>
    </div>
  </div>
  <div class="classReport">
    <h2>MethodAnnotation in package edu/umd/cs/findbugs</h2>
    <div class="methodBugReport">
      <ul class="violations">
        <li>
        CREATES_CUSTOM_OBJECTS - ON - INAPPROPRIATE
        </li>
      </ul>
      <pre><code>
/**
	 * Get the "full" method name.
	 * This is a format which looks sort of like a method signature
	 * that would appear in Java source code.
	 * 
	 * note: If shortenPackeges==true, this will return the same
	 * value as getNameInClass(), except that method caches the
	 * result and this one does not. Calling this one may be slow.
	 * 
	 * @param shortenPackages whether to shorten package names
	 * if they are in java or in the same package as this method.
	 * @param useJVMMethodName TODO
	 * @param hash TODO
	 */
public String getNameInClass(boolean shortenPackages, boolean useJVMMethodName, boolean hash, boolean omitMethodName) {
    StringBuilder result = new StringBuilder();
    if (!omitMethodName) {
        if (useJVMMethodName) result.append(getMethodName()); else result.append(getJavaSourceMethodName());
    }
    result.append('(');
    SignatureConverter converter = new SignatureConverter(methodSig);
    if (converter.getFirst() != '(') throw new IllegalStateException("bad method signature " + methodSig);
    converter.skip();
    boolean needsComma = false;
    while (converter.getFirst() != ')') {
        if (needsComma) if (hash) result.append(","); else result.append(", ");
        if (shortenPackages) result.append(removePackageName(converter.parseNext())); else result.append(converter.parseNext());
        needsComma = true;
    }
    converter.skip();
    result.append(')');
    return result.toString();
}
      </pre></code>
    </div>
  </div>
  <div class="classReport">
    <h2>OpcodeStack$Item in package edu/umd/cs/findbugs</h2>
    <div class="methodBugReport">
      <ul class="violations">
        <li>
        PARAMETER_TO_FIELD - ON - INAPPROPRIATE
        </li>
      </ul>
      <pre><code>

      </pre></code>
    </div>
  </div>
  <div class="classReport">
    <h2>OpcodeStack in package edu/umd/cs/findbugs</h2>
    <div class="methodBugReport">
      <ul class="violations">
        <li>
        RETURNS_INT - ON - NOTIFY
        </li>
      </ul>
      <pre><code>
public int resetForMethodEntry(final DismantleBytecode visitor) {
    this.v = visitor;
    initialize();
    int result = resetForMethodEntry0(v);
    Code code = v.getMethod().getCode();
    if (code == null) return result;
    if (useIterativeAnalysis) {
        IAnalysisCache analysisCache = Global.getAnalysisCache();
        XMethod xMethod = XFactory.createXMethod(v.getThisClass(), v.getMethod());
        try {
            JumpInfo jump = analysisCache.getMethodAnalysis(JumpInfo.class, xMethod.getMethodDescriptor());
            if (jump != null) {
                learnFrom(jump);
            }
        } catch (CheckedAnalysisException e) {
            AnalysisContext.logError("Error getting jump information", e);
        }
    }
    return result;
}
      </pre></code>
    </div>
    <div class="methodBugReport">
      <ul class="violations">
        <li>
        RETURNS_INT - ON - NOTIFY
        </li>
      </ul>
      <pre><code>
private int resetForMethodEntry0(PreorderVisitor visitor) {
    return resetForMethodEntry0(visitor.getClassName(), visitor.getMethod());
}
      </pre></code>
    </div>
    <div class="methodBugReport">
      <ul class="violations">
        <li>
        RETURNS_INT - ON - NOTIFY
        </li>
      </ul>
      <pre><code>
private int resetForMethodEntry0(@SlashedClassName String className, Method m) {
    methodName = m.getName();
    if (DEBUG) System.out.println(" --- ");
    String signature = m.getSignature();
    stack.clear();
    lvValues.clear();
    top = false;
    encountedTop = false;
    backwardsBranch = false;
    setReachOnlyByBranch(false);
    seenTransferOfControl = false;
    exceptionHandlers.clear();
    Code code = m.getCode();
    if (code != null) {
        CodeException[] exceptionTable = code.getExceptionTable();
        if (exceptionTable != null) for (CodeException ex : exceptionTable) exceptionHandlers.set(ex.getHandlerPC());
    }
    if (DEBUG) System.out.println(" --- " + className + " " + m.getName() + " " + signature);
    Type[] argTypes = Type.getArgumentTypes(signature);
    int reg = 0;
    if (!m.isStatic()) {
        Item it = new Item("L" + className + ";");
        it.setInitialParameter(true);
        it.registerNumber = reg;
        setLVValue(reg, it);
        reg += it.getSize();
    }
    for (Type argType : argTypes) {
        Item it = new Item(argType.getSignature());
        it.registerNumber = reg;
        it.setInitialParameter(true);
        setLVValue(reg, it);
        reg += it.getSize();
    }
    return reg;
}
      </pre></code>
    </div>
  </div>
  <div class="classReport">
    <h2>PluginLoader in package edu/umd/cs/findbugs</h2>
    <div class="methodBugReport">
      <ul class="violations">
        <li>
        RETURN_TYPE_IN_NAME - ON - INAPPROPRIATE
        </li>
      </ul>
      <pre><code>
@CheckForNull
private static Node findOptionalMessageNode(List<Document> messageCollectionList, String xpath) throws PluginException {
    for (Document document : messageCollectionList) {
        Node node = document.selectSingleNode(xpath);
        if (node != null) return node;
    }
    return null;
}
      </pre></code>
    </div>
  </div>
  <div class="classReport">
    <h2>SelfCalls in package edu/umd/cs/findbugs</h2>
    <div class="methodBugReport">
      <ul class="violations">
        <li>
        RETURNS_REFERENCE - ON - INAPPROPRIATE
        </li>
        <li>
        RETURNS_BOOLEAN - OFF - INAPPROPRIATE
        </li>
      </ul>
      <pre><code>
/**
	 * Is the given instruction a self-call?
	 */
private Method isSelfCall(InvokeInstruction inv) {
    ConstantPoolGen cpg = classContext.getConstantPoolGen();
    JavaClass jclass = classContext.getJavaClass();
    String calledClassName = inv.getClassName(cpg);
    if (!calledClassName.equals(jclass.getClassName())) return null;
    String calledMethodName = inv.getMethodName(cpg);
    String calledMethodSignature = inv.getSignature(cpg);
    boolean isStaticCall = (inv instanceof INVOKESTATIC);
    Method[] methods = jclass.getMethods();
    for (Method method : methods) {
        String methodName = method.getName();
        String signature = method.getSignature();
        boolean isStatic = method.isStatic();
        if (methodName.equals(calledMethodName) && signature.equals(calledMethodSignature) && isStatic == isStaticCall) {
            return wantCallsFor(method) ? method : null;
        }
    }
    if (DEBUG) System.out.println("No method found for " + calledClassName + "." + calledMethodName + " : " + calledMethodSignature);
    return null;
}
      </pre></code>
    </div>
  </div>
  <div class="classReport">
    <h2>VersionInsensitiveBugComparator in package edu/umd/cs/findbugs</h2>
    <div class="methodBugReport">
      <ul class="violations">
        <li>
        CREATES_CUSTOM_OBJECTS - ON - NOTIFY
        </li>
      </ul>
      <pre><code>
public int compare(BugInstance lhs, BugInstance rhs) {
    int cmp;
    BugPattern lhsPattern = lhs.getBugPattern();
    BugPattern rhsPattern = rhs.getBugPattern();
    if (lhsPattern == null || rhsPattern == null) {
        String lhsCode = getCode(lhs.getType());
        String rhsCode = getCode(rhs.getType());
        if ((cmp = lhsCode.compareTo(rhsCode)) != 0) {
            return cmp;
        }
    } else {
        if ((cmp = lhsPattern.getAbbrev().compareTo(rhsPattern.getAbbrev())) != 0) return cmp;
        if (isExactBugPatternMatch() && (cmp = lhsPattern.getType().compareTo(rhsPattern.getType())) != 0) return cmp;
    }
    if (comparePriorities) {
        cmp = lhs.getPriority() - rhs.getPriority();
        if (cmp != 0) return cmp;
    }
    Iterator<BugAnnotation> lhsIter = new FilteringAnnotationIterator(lhs.annotationIterator());
    Iterator<BugAnnotation> rhsIter = new FilteringAnnotationIterator(rhs.annotationIterator());
    while (lhsIter.hasNext() && rhsIter.hasNext()) {
        BugAnnotation lhsAnnotation = lhsIter.next();
        BugAnnotation rhsAnnotation = rhsIter.next();
        if (lhsAnnotation.getClass() != rhsAnnotation.getClass()) return lhsAnnotation.getClass().getName().compareTo(rhsAnnotation.getClass().getName());
        if (lhsAnnotation.getClass() == ClassAnnotation.class) {
            String lhsClassName = classNameRewriter.rewriteClassName(((ClassAnnotation) lhsAnnotation).getClassName());
            String rhsClassName = classNameRewriter.rewriteClassName(((ClassAnnotation) rhsAnnotation).getClassName());
            cmp = lhsClassName.compareTo(rhsClassName);
            if (cmp != 0) return cmp;
        } else if (lhsAnnotation.getClass() == MethodAnnotation.class) {
            MethodAnnotation lhsMethod = ClassNameRewriterUtil.convertMethodAnnotation(classNameRewriter, (MethodAnnotation) lhsAnnotation);
            MethodAnnotation rhsMethod = ClassNameRewriterUtil.convertMethodAnnotation(classNameRewriter, (MethodAnnotation) rhsAnnotation);
            cmp = lhsMethod.compareTo(rhsMethod);
            if (cmp != 0) return cmp;
        } else if (lhsAnnotation.getClass() == FieldAnnotation.class) {
            FieldAnnotation lhsField = ClassNameRewriterUtil.convertFieldAnnotation(classNameRewriter, (FieldAnnotation) lhsAnnotation);
            FieldAnnotation rhsField = ClassNameRewriterUtil.convertFieldAnnotation(classNameRewriter, (FieldAnnotation) rhsAnnotation);
            cmp = lhsField.compareTo(rhsField);
            if (cmp != 0) return cmp;
        } else if (lhsAnnotation.getClass() == StringAnnotation.class) {
            String lhsString = ((StringAnnotation) lhsAnnotation).getValue();
            String rhsString = ((StringAnnotation) rhsAnnotation).getValue();
            cmp = lhsString.compareTo(rhsString);
            if (cmp != 0) return cmp;
        } else if (lhsAnnotation.getClass() == LocalVariableAnnotation.class) {
            String lhsName = ((LocalVariableAnnotation) lhsAnnotation).getName();
            String rhsName = ((LocalVariableAnnotation) rhsAnnotation).getName();
            if (lhsName.equals("?") && rhsName.equals("?")) continue;
            cmp = lhsName.compareTo(rhsName);
            if (cmp != 0) return cmp;
        } else if (lhsAnnotation.getClass() == TypeAnnotation.class) {
            String lhsType = ((TypeAnnotation) lhsAnnotation).getTypeDescriptor();
            String rhsType = ((TypeAnnotation) rhsAnnotation).getTypeDescriptor();
            lhsType = ClassNameRewriterUtil.rewriteSignature(classNameRewriter, lhsType);
            rhsType = ClassNameRewriterUtil.rewriteSignature(classNameRewriter, rhsType);
            cmp = lhsType.compareTo(rhsType);
            if (cmp != 0) return cmp;
        } else if (lhsAnnotation.getClass() == IntAnnotation.class) {
            int lhsValue = ((IntAnnotation) lhsAnnotation).getValue();
            int rhsValue = ((IntAnnotation) rhsAnnotation).getValue();
            cmp = lhsValue - rhsValue;
            if (cmp != 0) return cmp;
        } else if (isBoring(lhsAnnotation)) {
            throw new IllegalStateException("Impossible");
        } else throw new IllegalStateException("Unknown annotation type: " + lhsAnnotation.getClass().getName());
    }
    if (rhsIter.hasNext()) return -1; else if (lhsIter.hasNext()) return 1; else return 0;
}
      </pre></code>
    </div>
  </div>
  <div class="classReport">
    <h2>XDocsBugReporter in package edu/umd/cs/findbugs</h2>
    <div class="methodBugReport">
      <ul class="violations">
        <li>
        RETURN_TYPE_IN_NAME - ON - INAPPROPRIATE
        </li>
      </ul>
      <pre><code>
private Document endDocument(Project project) {
    Element errorsElement = root.addElement(ERRORS_ELEMENT_NAME);
    for (Iterator<AnalysisError> i = bugCollection.errorIterator(); i.hasNext(); ) {
        AnalysisError analysisError = i.next();
        errorsElement.addElement(ANALYSIS_ERROR_ELEMENT_NAME).setText(analysisError.getMessage());
    }
    for (Iterator<String> i = bugCollection.missingClassIterator(); i.hasNext(); ) {
        errorsElement.addElement(MISSING_CLASS_ELEMENT_NAME).setText(i.next());
    }
    return document;
}
      </pre></code>
    </div>
  </div>
  <div class="classReport">
    <h2>AbstractDataflow in package edu/umd/cs/findbugs/ba</h2>
    <div class="methodBugReport">
      <ul class="violations">
        <li>
        PARAMETER_TYPE_IN_NAME - ON - INAPPROPRIATE
        </li>
      </ul>
      <pre><code>
/**
	 * Get the fact that is true on the given control edge.
	 * 
	 * @param edge the edge
	 * @return the fact that is true on the edge
	 * @throws DataflowAnalysisException 
	 */
@Override
public Fact getFactOnEdge(Edge edge) throws DataflowAnalysisException {
    return getAnalysis().getFactOnEdge(edge);
}
      </pre></code>
    </div>
  </div>
  <div class="classReport">
    <h2>AbstractDataflowAnalysis in package edu/umd/cs/findbugs/ba</h2>
    <div class="methodBugReport">
      <ul class="violations">
        <li>
        PARAMETER_TYPE_IN_NAME - ON - INAPPROPRIATE
        </li>
      </ul>
      <pre><code>
/**
	 * Get the dataflow fact representing the point just after given Location.
	 * Note "after" is meant in the logical sense, so for backward analyses,
	 * after means before the location in the control flow sense.
	 * 
	 * @param location the location
	 * @return the fact at the point just after the location
	 */
@Override
public Fact getFactAfterLocation(Location location) throws DataflowAnalysisException {
    BasicBlock basicBlock = location.getBasicBlock();
    InstructionHandle handle = location.getHandle();
    if (handle == (isForwards() ? basicBlock.getLastInstruction() : basicBlock.getFirstInstruction())) return getResultFact(basicBlock); else return getFactAtLocation(new Location(isForwards() ? handle.getNext() : handle.getPrev(), basicBlock));
}
      </pre></code>
    </div>
  </div>
  <div class="classReport">
    <h2>AbstractFrameModelingVisitor in package edu/umd/cs/findbugs/ba</h2>
    <div class="methodBugReport">
      <ul class="violations">
        <li>
        PARAMETER_TYPE_IN_NAME - ON - NOTIFY
        </li>
      </ul>
      <pre><code>
/**
	 * Model the stack for instructions handled by handleNormalInstruction().
	 * Subclasses may override to provide analysis-specific behavior.
	 * 
	 * @param ins              the Instruction to model
	 * @param numWordsConsumed number of stack words consumed
	 * @param numWordsProduced number of stack words produced
	 */
public void modelNormalInstruction(Instruction ins, int numWordsConsumed, int numWordsProduced) {
    modelInstruction(ins, numWordsConsumed, numWordsProduced, getDefaultValue());
}
      </pre></code>
    </div>
  </div>
  <div class="classReport">
    <h2>AbstractMethod in package edu/umd/cs/findbugs/ba</h2>
    <div class="methodBugReport">
      <ul class="violations">
        <li>
        CREATES_CUSTOM_OBJECTS - ON - NOTIFY
        </li>
        <li>
        CREATES_REGULAR_OBJECTS - ON - NOTIFY
        </li>
      </ul>
      <pre><code>
public int getNumParams() {
    return new SignatureParser(getSignature()).getNumParameters();
}
      </pre></code>
    </div>
  </div>
  <div class="classReport">
    <h2>AnalysisContext in package edu/umd/cs/findbugs/ba</h2>
    <div class="methodBugReport">
      <ul class="violations">
        <li>
        RETURNS_FIELD_VALUE - ON - INAPPROPRIATE
        </li>
      </ul>
      <pre><code>
public boolean setMissingClassWarningsSuppressed(boolean value) {
    boolean oldValue = missingClassWarningsSuppressed;
    missingClassWarningsSuppressed = value;
    return oldValue;
}
      </pre></code>
    </div>
  </div>
  <div class="classReport">
    <h2>AnnotationDatabase in package edu/umd/cs/findbugs/ba</h2>
    <div class="methodBugReport">
      <ul class="violations">
        <li>
        RETURNS_FIELD_VALUE - ON - INAPPROPRIATE
        </li>
        <li>
        RETURNS_VOID - OFF - NOTIFY
        </li>
      </ul>
      <pre><code>
public boolean setAddClassOnly(boolean newValue) {
    boolean oldValue = addClassOnly;
    addClassOnly = newValue;
    return oldValue;
}
      </pre></code>
    </div>
  </div>
  <div class="classReport">
    <h2>BasicAbstractDataflowAnalysis in package edu/umd/cs/findbugs/ba</h2>
    <div class="methodBugReport">
      <ul class="violations">
        <li>
        PARAMETER_TYPE_IN_NAME - ON - INAPPROPRIATE
        </li>
      </ul>
      <pre><code>
/**
	 * Get the fact that is true on the given control edge,
	 * <em>after applying the edge transfer function</em> (if any).
	 * 
	 * @param edge the edge
	 * @return the fact that is true after applying the edge transfer function
	 * @throws DataflowAnalysisException 
	 */
public Fact getFactOnEdge(Edge edge) throws DataflowAnalysisException {
    BasicBlock block = isForwards() ? edge.getSource() : edge.getTarget();
    Fact predFact = createFact();
    copy(getResultFact(block), predFact);
    edgeTransfer(edge, predFact);
    Fact result = createFact();
    makeFactTop(result);
    meetInto(predFact, edge, result);
    return result;
}
      </pre></code>
    </div>
  </div>
  <div class="classReport">
    <h2>ClassHash in package edu/umd/cs/findbugs/ba</h2>
    <div class="methodBugReport">
      <ul class="violations">
        <li>
        RETURNS_STRING - ON - NOTIFY
        </li>
        <li>
        RETURNS_INT - OFF - INAPPROPRIATE
        </li>
        <li>
        RETURN_TYPE_IN_NAME - ON - FORBIDDEN
        </li>
      </ul>
      <pre><code>
/**
	 * Convert a hash to a string of hex digits.
	 *
	 * @param hash the hash
	 * @return a String representation of the hash
	 */
public static String hashToString(byte[] hash) {
    StringBuilder buf = new StringBuilder();
    for (byte b : hash) {
        buf.append(HEX_CHARS[(b >> 4) & 0xF]);
        buf.append(HEX_CHARS[b & 0xF]);
    }
    return buf.toString();
}
      </pre></code>
    </div>
  </div>
  <div class="classReport">
    <h2>DataflowCFGPrinter in package edu/umd/cs/findbugs/ba</h2>
    <div class="methodBugReport">
      <ul class="violations">
        <li>
        CREATES_OWN_CLASS_OBJECTS - ON - FORBIDDEN
        </li>
      </ul>
      <pre><code>
/**
	 * Print CFG annotated with results from given dataflow analysis.
	 * 
	 * @param <Fact>         Dataflow fact type
	 * @param <AnalysisType> Dataflow analysis type
	 * @param dataflow       dataflow driver
	 * @param out            PrintStream to use
	 */
public static <Fact, AnalysisType extends BasicAbstractDataflowAnalysis<Fact>> void printCFG(Dataflow<Fact, AnalysisType> dataflow, PrintStream out) {
    DataflowCFGPrinter<Fact, AnalysisType> printer = new DataflowCFGPrinter<Fact, AnalysisType>(dataflow);
    printer.print(out);
}
      </pre></code>
    </div>
  </div>
  <div class="classReport">
    <h2>Edge in package edu/umd/cs/findbugs/ba</h2>
    <div class="methodBugReport">
      <ul class="violations">
        <li>
        TYPE_MANIPULATOR - ON - NOTIFY
        </li>
      </ul>
      <pre><code>
@Override
public int hashCode() {
    return 2003 * getSource().getLabel() + getTarget().getLabel();
}
      </pre></code>
    </div>
  </div>
  <div class="classReport">
    <h2>Location in package edu/umd/cs/findbugs/ba</h2>
    <div class="methodBugReport">
      <ul class="violations">
        <li>
        CREATES_OWN_CLASS_OBJECTS - ON - FORBIDDEN
        </li>
      </ul>
      <pre><code>
public static Location getFirstLocation(@NonNull BasicBlock basicBlock) {
    InstructionHandle location = basicBlock.getFirstInstruction();
    if (location == null) return null;
    return new Location(location, basicBlock);
}
      </pre></code>
    </div>
    <div class="methodBugReport">
      <ul class="violations">
        <li>
        CREATES_OWN_CLASS_OBJECTS - ON - NOTIFY
        </li>
      </ul>
      <pre><code>
public static Location getLastLocation(@NonNull BasicBlock basicBlock) {
    InstructionHandle lastInstruction = basicBlock.getLastInstruction();
    if (lastInstruction == null) return null;
    return new Location(lastInstruction, basicBlock);
}
      </pre></code>
    </div>
  </div>
  <div class="classReport">
    <h2>SignatureParser in package edu/umd/cs/findbugs/ba</h2>
    <div class="methodBugReport">
      <ul class="violations">
        <li>
        CREATES_OWN_CLASS_OBJECTS - ON - FORBIDDEN
        </li>
      </ul>
      <pre><code>
/**
	 * Get the number of parameters passed to method invocation.
	 * 
	 * @param inv
	 * @param cpg
	 * @return int number of parameters
	 */
public static int getNumParametersForInvocation(InvokeInstruction inv, ConstantPoolGen cpg) {
    SignatureParser sigParser = new SignatureParser(inv.getSignature(cpg));
    return sigParser.getNumParameters();
}
      </pre></code>
    </div>
  </div>
  <div class="classReport">
    <h2>UnresolvedXMethod in package edu/umd/cs/findbugs/ba</h2>
    <div class="methodBugReport">
      <ul class="violations">
        <li>
        CREATES_CUSTOM_OBJECTS - ON - INAPPROPRIATE
        </li>
      </ul>
      <pre><code>
public boolean isReturnTypeReferenceType() {
    SignatureParser parser = new SignatureParser(getSignature());
    String returnTypeSig = parser.getReturnTypeSignature();
    return SignatureParser.isReferenceType(returnTypeSig);
}
      </pre></code>
    </div>
  </div>
  <div class="classReport">
    <h2>ByteCodePattern in package edu/umd/cs/findbugs/ba/bcp</h2>
    <div class="methodBugReport">
      <ul class="violations">
        <li>
        RETURNS_REFERENCE - ON - NOTIFY
        </li>
      </ul>
      <pre><code>
/**
	 * Set number of inter-element wildcards to create between
	 * explicit PatternElements.  By default, no implicit wildcards
	 * are created.
	 *
	 * @param numWild the number of wildcard instructions which
	 *                may be matched between explicit PatternElements
	 * @return this object
	 */
public ByteCodePattern setInterElementWild(int numWild) {
    this.interElementWild = numWild;
    return this;
}
      </pre></code>
    </div>
    <div class="methodBugReport">
      <ul class="violations">
        <li>
        RETURNS_REFERENCE - ON - INAPPROPRIATE
        </li>
        <li>
        RETURNS_BOOLEAN - OFF - INAPPROPRIATE
        </li>
        <li>
        RETURN_TYPE_IN_NAME - ON - FORBIDDEN
        </li>
      </ul>
      <pre><code>
private Wild isLastWild() {
    if (last != null && last instanceof Wild) return (Wild) last; else return null;
}
      </pre></code>
    </div>
  </div>
  <div class="classReport">
    <h2>MatchAny in package edu/umd/cs/findbugs/ba/bcp</h2>
    <div class="methodBugReport">
      <ul class="violations">
        <li>
        RETURNS_REFERENCE - ON - INAPPROPRIATE
        </li>
        <li>
        RETURNS_VOID - OFF - INAPPROPRIATE
        </li>
        <li>
        CONTAINS_LOOP - ON - INAPPROPRIATE
        </li>
      </ul>
      <pre><code>
@Override
public PatternElement setAllowTrailingEdges(boolean allowTrailingEdges) {
    for (PatternElement aChildList : childList) aChildList.setAllowTrailingEdges(allowTrailingEdges);
    return this;
}
      </pre></code>
    </div>
  </div>
  <div class="classReport">
    <h2>PatternElement in package edu/umd/cs/findbugs/ba/bcp</h2>
    <div class="methodBugReport">
      <ul class="violations">
        <li>
        RETURNS_REFERENCE - ON - INAPPROPRIATE
        </li>
        <li>
        RETURNS_VOID - OFF - INAPPROPRIATE
        </li>
      </ul>
      <pre><code>
/**
	 * Set whether or not this PatternElement allows trailing edges to be matched.
	 * By default, trailing edges may be matched.  When this value is set
	 * to false, it ensures that the successor instruction must be in the
	 * same basic block.
	 *
	 * @param allowTrailingEdges true if trailing edges may be matched,
	 *                           false if trailing edges will never be matched
	 */
public PatternElement setAllowTrailingEdges(boolean allowTrailingEdges) {
    this.allowTrailingEdges = allowTrailingEdges;
    return this;
}
      </pre></code>
    </div>
  </div>
  <div class="classReport">
    <h2>Subtypes2 in package edu/umd/cs/findbugs/ba/ch</h2>
    <div class="methodBugReport">
      <ul class="violations">
        <li>
        RETURN_TYPE_IN_NAME - ON - INAPPROPRIATE
        </li>
      </ul>
      <pre><code>
/**
	 * Add an XClass and all of its supertypes to
	 * the InheritanceGraph.
	 * 
	 * @param xclass an XClass
	 * @return the ClassVertex representing the class in 
	 *         the InheritanceGraph
	 */
private ClassVertex addClassAndGetClassVertex(XClass xclass) {
    if (xclass == null) {
        throw new IllegalStateException();
    }
    LinkedList<XClass> workList = new LinkedList<XClass>();
    workList.add(xclass);
    while (!workList.isEmpty()) {
        XClass work = workList.removeFirst();
        ClassVertex vertex = classDescriptorToVertexMap.get(work.getClassDescriptor());
        if (vertex != null && vertex.isFinished()) {
            continue;
        }
        if (vertex == null) {
            vertex = ClassVertex.createResolvedClassVertex(work.getClassDescriptor(), work);
            addVertexToGraph(work.getClassDescriptor(), vertex);
        }
        addSupertypeEdges(vertex, workList);
        vertex.setFinished(true);
    }
    return classDescriptorToVertexMap.get(xclass.getClassDescriptor());
}
      </pre></code>
    </div>
    <div class="methodBugReport">
      <ul class="violations">
        <li>
        RETURN_TYPE_IN_NAME - ON - NOTIFY
        </li>
      </ul>
      <pre><code>
/**
     * @param classDescriptor
     * @return
     */
private ClassVertex optionallyResolveClassVertex(ClassDescriptor classDescriptor) {
    ClassVertex typeVertex = classDescriptorToVertexMap.get(classDescriptor);
    if (typeVertex == null) {
        XClass xclass = AnalysisContext.currentXFactory().getXClass(classDescriptor);
        if (xclass == null) {
            typeVertex = addClassVertexForMissingClass(classDescriptor, false);
        } else {
            typeVertex = addClassAndGetClassVertex(xclass);
        }
    }
    return typeVertex;
}
      </pre></code>
    </div>
  </div>
  <div class="classReport">
    <h2>Constant in package edu/umd/cs/findbugs/ba/constant</h2>
    <div class="methodBugReport">
      <ul class="violations">
        <li>
        RETURN_TYPE_IN_NAME - ON - NOTIFY
        </li>
      </ul>
      <pre><code>
/**
	 * Get the constant String value of this value.
	 * 
	 * @return the constant String value
	 */
public String getConstantString() {
    return (String) value;
}
      </pre></code>
    </div>
  </div>
  <div class="classReport">
    <h2>UnconditionalValueDerefAnalysis in package edu/umd/cs/findbugs/ba/deref</h2>
    <div class="methodBugReport">
      <ul class="violations">
        <li>
        PARAMETER_TO_FIELD - ON - NOTIFY
        </li>
      </ul>
      <pre><code>
/**
	 * HACK: use the given is-null dataflow to clear deref sets for
	 * values that are known to be definitely non-null on a branch.
	 * 
	 * @param invDataflow the IsNullValueDataflow to use
	 */
public void clearDerefsOnNonNullBranches(IsNullValueDataflow invDataflow) {
    this.invDataflow = invDataflow;
}
      </pre></code>
    </div>
  </div>
  <div class="classReport">
    <h2>GenericObjectType in package edu/umd/cs/findbugs/ba/generic</h2>
    <div class="methodBugReport">
      <ul class="violations">
        <li>
        RETURN_TYPE_IN_NAME - ON - NOTIFY
        </li>
      </ul>
      <pre><code>
public String getGenericParametersAsString() {
    if (getTypeCategory() != GenericUtilities.TypeCategory.PARAMETERIZED) throw new IllegalStateException(toString() + " doesn't have generic parameters");
    String baseStringValue = super.toString();
    String fullStringValue = toString();
    return fullStringValue.substring(baseStringValue.length());
}
      </pre></code>
    </div>
  </div>
  <div class="classReport">
    <h2>GenericSignatureParser in package edu/umd/cs/findbugs/ba/generic</h2>
    <div class="methodBugReport">
      <ul class="violations">
        <li>
        CREATES_OWN_CLASS_OBJECTS - ON - FORBIDDEN
        </li>
      </ul>
      <pre><code>
/**
	 * Get the number of parameters passed to method invocation.
	 * 
	 * @param inv
	 * @param cpg
	 * @return int number of parameters
	 */
public static int getNumParametersForInvocation(InvokeInstruction inv, ConstantPoolGen cpg) {
    GenericSignatureParser sigParser = new GenericSignatureParser(inv.getSignature(cpg));
    return sigParser.getNumParameters();
}
      </pre></code>
    </div>
  </div>
  <div class="classReport">
    <h2>Analysis in package edu/umd/cs/findbugs/ba/jsr305</h2>
    <div class="methodBugReport">
      <ul class="violations">
        <li>
        RETURNS_VOID - ON - NOTIFY
        </li>
      </ul>
      <pre><code>
private static void getDirectlyRelevantTypeQualifiers(XMethod xmethod, HashSet<TypeQualifierValue> result) {
    result.addAll(AnalysisContext.currentAnalysisContext().getDirectlyRelevantTypeQualifiersDatabase().getDirectlyRelevantTypeQualifiers(xmethod.getMethodDescriptor()));
}
      </pre></code>
    </div>
  </div>
  <div class="classReport">
    <h2>TypeQualifierAnnotation in package edu/umd/cs/findbugs/ba/jsr305</h2>
    <div class="methodBugReport">
      <ul class="violations">
        <li>
        CREATES_OWN_CLASS_OBJECTS - ON - INAPPROPRIATE
        </li>
      </ul>
      <pre><code>
@NonNull
public static TypeQualifierAnnotation getValue(TypeQualifierValue desc, When when) {
    DualKeyHashMap<TypeQualifierValue, When, TypeQualifierAnnotation> map = instance.get();
    TypeQualifierAnnotation result = map.get(desc, when);
    if (result != null) return result;
    result = new TypeQualifierAnnotation(desc, when);
    map.put(desc, when, result);
    return result;
}
      </pre></code>
    </div>
  </div>
  <div class="classReport">
    <h2>TypeQualifierValue in package edu/umd/cs/findbugs/ba/jsr305</h2>
    <div class="methodBugReport">
      <ul class="violations">
        <li>
        CREATES_OWN_CLASS_OBJECTS - ON - INAPPROPRIATE
        </li>
      </ul>
      <pre><code>
/**
	 * Given a ClassDescriptor/value pair, return the
	 * interned TypeQualifierValue representing that pair.
	 *
	 * @param desc  a ClassDescriptor denoting a type qualifier annotation
	 * @param value a value
	 * @return an interned TypeQualifierValue object
	 */
@NonNull
public static TypeQualifierValue getValue(ClassDescriptor desc, Object value) {
    DualKeyHashMap<ClassDescriptor, Object, TypeQualifierValue> map = instance.get().typeQualifierMap;
    TypeQualifierValue result = map.get(desc, value);
    if (result != null) return result;
    result = new TypeQualifierValue(desc, value);
    determineIfQualifierIsStrict(desc, result);
    determineIfQualifierIsExclusiveOrExhaustive(desc, result);
    map.put(desc, value, result);
    instance.get().allKnownTypeQualifiers.add(result);
    return result;
}
      </pre></code>
    </div>
  </div>
  <div class="classReport">
    <h2>NullValueUnconditionalDeref in package edu/umd/cs/findbugs/ba/npe</h2>
    <div class="methodBugReport">
      <ul class="violations">
        <li>
        RETURN_TYPE_IN_NAME - ON - NOTIFY
        </li>
      </ul>
      <pre><code>
/**
	 * @return Returns the derefLocationSet.
	 */
public Set<Location> getDerefLocationSet() {
    return derefLocationSet;
}
      </pre></code>
    </div>
  </div>
  <div class="classReport">
    <h2>StateSet in package edu/umd/cs/findbugs/ba/obl</h2>
    <div class="methodBugReport">
      <ul class="violations">
        <li>
        RETURN_TYPE_IN_NAME - ON - NOTIFY
        </li>
      </ul>
      <pre><code>
/**
	 * Get Set of all ObligationsSets in this StateSet.
	 * 
	 * @return Set of all ObligationsSets in this StateSet
	 */
public Set<ObligationSet> getAllObligationSets() {
    return Collections.unmodifiableSet(stateMap.keySet());
}
      </pre></code>
    </div>
  </div>
  <div class="classReport">
    <h2>TypeFrameModelingVisitor in package edu/umd/cs/findbugs/ba/type</h2>
    <div class="methodBugReport">
      <ul class="violations">
        <li>
        RETURN_TYPE_IN_NAME - ON - NOTIFY
        </li>
      </ul>
      <pre><code>
/**
	 * Get the type of the most recent instanceof instruction modeled.
	 * The TypeAnalysis may use this to get more precise types in
	 * the resulting frame.
	 * 
	 * @return the Type checked by the most recent instanceof instruction
	 */
public Type getInstanceOfType() {
    return instanceOfType;
}
      </pre></code>
    </div>
    <div class="methodBugReport">
      <ul class="violations">
        <li>
        RETURN_TYPE_IN_NAME - ON - NOTIFY
        </li>
      </ul>
      <pre><code>
/**
	 * Get the value number of the most recent instanceof instruction modeled.
	 * The TypeAnalysis may use this to get more precise types in
	 * the resulting frame.
	 * 
	 * @return the ValueNumber checked by the most recent instanceof instruction
	 */
public ValueNumber getInstanceOfValueNumber() {
    return instanceOfValueNumber;
}
      </pre></code>
    </div>
    <div class="methodBugReport">
      <ul class="violations">
        <li>
        PARAMETER_TYPE_IN_NAME - ON - NOTIFY
        </li>
      </ul>
      <pre><code>
/**
	 * This is overridden only to ensure that we don't rely on the
	 * base class to handle instructions that produce stack operands.
	 */
@Override
public void modelNormalInstruction(Instruction ins, int numWordsConsumed, int numWordsProduced) {
    if (VERIFY_INTEGRITY) {
        if (numWordsProduced > 0) throw new InvalidBytecodeException("missing visitor method for " + ins);
    }
    super.modelNormalInstruction(ins, numWordsConsumed, numWordsProduced);
}
      </pre></code>
    </div>
  </div>
  <div class="classReport">
    <h2>ValueNumberFrameModelingVisitor in package edu/umd/cs/findbugs/ba/vna</h2>
    <div class="methodBugReport">
      <ul class="violations">
        <li>
        PARAMETER_TYPE_IN_NAME - ON - NOTIFY
        </li>
      </ul>
      <pre><code>
/**
	 * This is the default instruction modeling method.
	 */
@Override
public void modelNormalInstruction(Instruction ins, int numWordsConsumed, int numWordsProduced) {
    int flags = 0;
    if (ins instanceof InvokeInstruction) flags = ValueNumber.RETURN_VALUE; else if (ins instanceof ArrayInstruction) flags = ValueNumber.ARRAY_VALUE;
    ValueNumber[] inputValueList = popInputValues(numWordsConsumed);
    ValueNumber[] outputValueList = getOutputValues(inputValueList, numWordsProduced, flags);
    if (VERIFY_INTEGRITY) {
        checkConsumedAndProducedValues(ins, inputValueList, outputValueList);
    }
    pushOutputValues(outputValueList);
}
      </pre></code>
    </div>
  </div>
  <div class="classReport">
    <h2>ValueNumberSourceInfo in package edu/umd/cs/findbugs/ba/vna</h2>
    <div class="methodBugReport">
      <ul class="violations">
        <li>
        PARAMETER_TYPE_IN_NAME - ON - INAPPROPRIATE
        </li>
      </ul>
      <pre><code>
/**
	 * @param method
	 * @param location
	 * @param valueNumber
	 * @param vnaFrame
	 * @param partialRole TODO
	 * @return the annotation
	 */
@Nonnull
public static BugAnnotation findRequiredAnnotationFromValueNumber(Method method, Location location, ValueNumber valueNumber, ValueNumberFrame vnaFrame, @CheckForNull String partialRole) {
    BugAnnotation result = findAnnotationFromValueNumber(method, location, valueNumber, vnaFrame, partialRole);
    if (result != null) return result;
    return new LocalVariableAnnotation("?", -1, location.getHandle().getPosition());
}
      </pre></code>
    </div>
  </div>
  <div class="classReport">
    <h2>FieldInfo in package edu/umd/cs/findbugs/classfile/analysis</h2>
    <div class="methodBugReport">
      <ul class="violations">
        <li>
        CREATES_CUSTOM_OBJECTS - ON - NOTIFY
        </li>
        <li>
        CREATES_REGULAR_OBJECTS - ON - NOTIFY
        </li>
      </ul>
      <pre><code>
public int getNumParams() {
    return new SignatureParser(getSignature()).getNumParameters();
}
      </pre></code>
    </div>
  </div>
  <div class="classReport">
    <h2>MethodInfo in package edu/umd/cs/findbugs/classfile/analysis</h2>
    <div class="methodBugReport">
      <ul class="violations">
        <li>
        CREATES_CUSTOM_OBJECTS - ON - NOTIFY
        </li>
        <li>
        CREATES_REGULAR_OBJECTS - ON - NOTIFY
        </li>
      </ul>
      <pre><code>
public int getNumParams() {
    return new SignatureParser(getSignature()).getNumParameters();
}
      </pre></code>
    </div>
    <div class="methodBugReport">
      <ul class="violations">
        <li>
        CREATES_CUSTOM_OBJECTS - ON - INAPPROPRIATE
        </li>
      </ul>
      <pre><code>
public boolean isReturnTypeReferenceType() {
    SignatureParser parser = new SignatureParser(getSignature());
    String returnTypeSig = parser.getReturnTypeSignature();
    return SignatureParser.isReferenceType(returnTypeSig);
}
      </pre></code>
    </div>
  </div>
  <div class="classReport">
    <h2>DirectoryCodeBase in package edu/umd/cs/findbugs/classfile/impl</h2>
    <div class="methodBugReport">
      <ul class="violations">
        <li>
        FIELD_WRITER - ON - INAPPROPRIATE
        </li>
      </ul>
      <pre><code>
public ICodeBaseIterator iterator() throws InterruptedException {
    if (!searchPerformed) {
        rfs.search();
        searchPerformed = true;
    }
    return new DirectoryCodeBaseIterator();
}
      </pre></code>
    </div>
  </div>
  <div class="classReport">
    <h2>SingleFileCodeBase in package edu/umd/cs/findbugs/classfile/impl</h2>
    <div class="methodBugReport">
      <ul class="violations">
        <li>
        CREATES_REGULAR_OBJECTS - ON - NOTIFY
        </li>
      </ul>
      <pre><code>
/**
	 * Return the number of bytes in the file.
	 *
	 * @return the number of bytes in the file, or -1 if the file's length
	 *          can't be determined
	 */
int getNumBytes() {
    File file = new File(fileName);
    return (int) file.length();
}
      </pre></code>
    </div>
  </div>
  <div class="classReport">
    <h2>CommandLine in package edu/umd/cs/findbugs/config</h2>
    <div class="methodBugReport">
      <ul class="violations">
        <li>
        RETURNS_INT - ON - INAPPROPRIATE
        </li>
      </ul>
      <pre><code>
/**
	 * Parse switches/options, showing usage information if they can't be parsed,
	 * or if we have the wrong number of remaining arguments after parsing.
	 * Calls parse(String[]).
	 * 
	 * @param argv     command line arguments
	 * @param minArgs  allowed minimum number of arguments remaining after
	 *                 switches/options are parsed
	 * @param maxArgs  allowed maximum number of arguments remaining after
	 *                 switches/options are parsed
	 * @param usage    usage synopsis
	 * @return number of arguments parsed
	 */
@SuppressWarnings("DM_EXIT")
public int parse(String argv[], int minArgs, int maxArgs, String usage) {
    try {
        int count = parse(argv);
        int remaining = argv.length - count;
        if (remaining < minArgs || remaining > maxArgs) {
            System.out.println(usage);
            System.out.println("Expected " + minArgs + "..." + maxArgs + " file arguments, found " + remaining);
            System.out.println("Options:");
            printUsage(System.out);
            System.exit(1);
        }
        return count;
    } catch (HelpRequestedException e) {
    } catch (RuntimeException e) {
        e.printStackTrace();
    } catch (IOException e) {
        e.printStackTrace();
    }
    System.out.println(usage);
    System.out.println("Options:");
    printUsage(System.out);
    System.exit(1);
    return -1;
}
      </pre></code>
    </div>
    <div class="methodBugReport">
      <ul class="violations">
        <li>
        RETURNS_INT - ON - INAPPROPRIATE
        </li>
      </ul>
      <pre><code>
/**
	 * Parse a command line.
	 * Calls down to handleOption() and handleOptionWithArgument() methods.
	 * Stops parsing when it reaches the end of the command line,
	 * or when a command line argument not starting with "-" is seen.
	 *
	 * @param argv the arguments
	 * @return the number of arguments parsed; if equal to
	 *         argv.length, then the entire command line was parsed
	 * @throws HelpRequestedException 
	 */
public int parse(String argv[]) throws IOException, HelpRequestedException {
    return parse(argv, false);
}
      </pre></code>
    </div>
    <div class="methodBugReport">
      <ul class="violations">
        <li>
        RETURNS_INT - ON - INAPPROPRIATE
        </li>
      </ul>
      <pre><code>
private int parse(String argv[], boolean dryRun) throws IOException, HelpRequestedException {
    int arg = 0;
    while (arg < argv.length) {
        String option = argv[arg];
        if (option.equals("-help")) throw new HelpRequestedException();
        if (!option.startsWith("-")) break;
        String optionExtraPart = "";
        int colon = option.indexOf(':');
        if (colon >= 0) {
            optionExtraPart = option.substring(colon + 1);
            option = option.substring(0, colon);
        }
        if (optionDescriptionMap.get(option) == null) throw new IllegalArgumentException("Unknown option: " + option);
        if (requiresArgumentSet.contains(option)) {
            ++arg;
            if (arg >= argv.length) throw new IllegalArgumentException("Option " + option + " requires an argument");
            String argument = argv[arg];
            if (!dryRun) handleOptionWithArgument(option, argument);
            ++arg;
        } else {
            if (!dryRun) handleOption(option, optionExtraPart);
            ++arg;
        }
    }
    return arg;
}
      </pre></code>
    </div>
  </div>
  <div class="classReport">
    <h2>FindInconsistentSync2 in package edu/umd/cs/findbugs/detect</h2>
    <div class="methodBugReport">
      <ul class="violations">
        <li>
        PARAMETER_TYPE_IN_NAME - ON - INAPPROPRIATE
        </li>
      </ul>
      <pre><code>
/**
	 * Determine whether or not the the given method is
	 * a getter method.  I.e., if it just returns the
	 * value of an instance field.
	 *
	 * @param classContext the ClassContext for the class containing the method
	 * @param method       the method
	 */
@SuppressWarnings("unchecked")
public static boolean isGetterMethod(ClassContext classContext, Method method) {
    MethodGen methodGen = classContext.getMethodGen(method);
    if (methodGen == null) return false;
    InstructionList il = methodGen.getInstructionList();
    if (il.getLength() > 60) return false;
    int count = 0;
    Iterator<InstructionHandle> it = il.iterator();
    while (it.hasNext()) {
        InstructionHandle ih = it.next();
        switch(ih.getInstruction().getOpcode()) {
            case Constants.GETFIELD:
                count++;
                if (count > 1) return false;
                break;
            case Constants.PUTFIELD:
            case Constants.BALOAD:
            case Constants.CALOAD:
            case Constants.DALOAD:
            case Constants.FALOAD:
            case Constants.IALOAD:
            case Constants.LALOAD:
            case Constants.SALOAD:
            case Constants.AALOAD:
            case Constants.BASTORE:
            case Constants.CASTORE:
            case Constants.DASTORE:
            case Constants.FASTORE:
            case Constants.IASTORE:
            case Constants.LASTORE:
            case Constants.SASTORE:
            case Constants.AASTORE:
            case Constants.PUTSTATIC:
                return false;
            case Constants.INVOKESTATIC:
            case Constants.INVOKEVIRTUAL:
            case Constants.INVOKEINTERFACE:
            case Constants.INVOKESPECIAL:
            case Constants.GETSTATIC:
        }
    }
    return true;
}
      </pre></code>
    </div>
  </div>
  <div class="classReport">
    <h2>FindUnreleasedLock$LockResourceTracker in package edu/umd/cs/findbugs/detect</h2>
    <div class="methodBugReport">
      <ul class="violations">
        <li>
        RETURNS_REFERENCE - ON - INAPPROPRIATE
        </li>
        <li>
        RETURNS_CREATED_OBJECT - ON - INAPPROPRIATE
        </li>
        <li>
        RETURNS_BOOLEAN - OFF - INAPPROPRIATE
        </li>
      </ul>
      <pre><code>

      </pre></code>
    </div>
  </div>
  <div class="classReport">
    <h2>Stream in package edu/umd/cs/findbugs/detect</h2>
    <div class="methodBugReport">
      <ul class="violations">
        <li>
        RETURNS_REFERENCE - ON - INAPPROPRIATE
        </li>
        <li>
        RETURNS_VOID - OFF - INAPPROPRIATE
        </li>
      </ul>
      <pre><code>
/**
	 * Mark whether or not Stream is open as soon as it is created,
	 * or whether a later method or constructor must explicitly
	 * open it.
	 */
public Stream setIsOpenOnCreation(boolean enable) {
    isOpenOnCreation = enable;
    return this;
}
      </pre></code>
    </div>
  </div>
  <div class="classReport">
    <h2>StreamResourceTracker in package edu/umd/cs/findbugs/detect</h2>
    <div class="methodBugReport">
      <ul class="violations">
        <li>
        RETURNS_REFERENCE - ON - INAPPROPRIATE
        </li>
        <li>
        RETURNS_BOOLEAN - OFF - INAPPROPRIATE
        </li>
      </ul>
      <pre><code>
public Stream isResourceCreation(BasicBlock basicBlock, InstructionHandle handle, ConstantPoolGen cpg) {
    if (resourceCollection != null) return resourceCollection.getCreatedResource(new Location(handle, basicBlock));
    Instruction ins = handle.getInstruction();
    if (!(ins instanceof TypedInstruction)) return null;
    Type type = ((TypedInstruction) ins).getType(cpg);
    if (!(type instanceof ObjectType)) return null;
    Location location = new Location(handle, basicBlock);
    for (StreamFactory aStreamFactoryList : streamFactoryList) {
        Stream stream = aStreamFactoryList.createStream(location, (ObjectType) type, cpg, lookupFailureCallback);
        if (stream != null) return stream;
    }
    return null;
}
      </pre></code>
    </div>
  </div>
  <div class="classReport">
    <h2>CompoundMatcher in package edu/umd/cs/findbugs/filter</h2>
    <div class="methodBugReport">
      <ul class="violations">
        <li>
        TYPE_MANIPULATOR - ON - NOTIFY
        </li>
      </ul>
      <pre><code>
@Override
public int hashCode() {
    int result = this.getClass().hashCode();
    for (Matcher m : children) result += m.hashCode();
    return result;
}
      </pre></code>
    </div>
  </div>
  <div class="classReport">
    <h2>StronglyConnectedComponents in package edu/umd/cs/findbugs/graph</h2>
    <div class="methodBugReport">
      <ul class="violations">
        <li>
        RETURN_TYPE_IN_NAME - ON - NOTIFY
        </li>
      </ul>
      <pre><code>
/**
	 * Make a copy of given search tree (in the transposed graph)
	 * using vertices of the original graph.
	 *
	 * @param tree a search tree in the transposed graph
	 * @param t    the Transpose object which performed the transposition of
	 *             the original graph
	 */
private SearchTree<VertexType> copySearchTree(SearchTree<VertexType> tree, Transpose<GraphType, EdgeType, VertexType> t) {
    SearchTree<VertexType> copy = new SearchTree<VertexType>(t.getOriginalGraphVertex(tree.getVertex()));
    Iterator<SearchTree<VertexType>> i = tree.childIterator();
    while (i.hasNext()) {
        SearchTree<VertexType> child = i.next();
        copy.addChild(copySearchTree(child, t));
    }
    return copy;
}
      </pre></code>
    </div>
    <div class="methodBugReport">
      <ul class="violations">
        <li>
        RETURN_TYPE_IN_NAME - ON - INAPPROPRIATE
        </li>
      </ul>
      <pre><code>
/**
	 * Returns an iterator over the sets of vertices
	 * of each strongly connected component.
	 *
	 * @return an Iterator over a sequence of Set objects
	 */
public Iterator<Set<VertexType>> setIterator() {
    return new SCCSetIterator();
}
      </pre></code>
    </div>
  </div>
  <div class="classReport">
    <h2>AnalysisRun in package edu/umd/cs/findbugs/gui</h2>
    <div class="methodBugReport">
      <ul class="violations">
        <li>
        PARAMETER_TYPE_IN_NAME - ON - NOTIFY
        </li>
      </ul>
      <pre><code>
/**
	 * Load bugs from a file.
	 */
public void loadBugsFromFile(File file) throws IOException, org.dom4j.DocumentException {
    reporter.getBugCollection().readXML(file);
    summary = reporter.getBugCollection().getSummaryHTML();
}
      </pre></code>
    </div>
    <div class="methodBugReport">
      <ul class="violations">
        <li>
        PARAMETER_TYPE_IN_NAME - ON - NOTIFY
        </li>
      </ul>
      <pre><code>
/**
	 * Load bugs from an InputStream.
	 * 
	 * @param in the InputStream
	 * @throws IOException
	 * @throws DocumentException
	 */
public void loadBugsFromInputStream(InputStream in) throws IOException, DocumentException {
    reporter.getBugCollection().readXML(in);
    summary = reporter.getBugCollection().getSummaryHTML();
}
      </pre></code>
    </div>
  </div>
  <div class="classReport">
    <h2>DefaultSortedTableModel in package edu/umd/cs/findbugs/gui</h2>
    <div class="methodBugReport">
      <ul class="violations">
        <li>
        PARAMETER_TO_FIELD_CALL - ON - FORBIDDEN
        </li>
      </ul>
      <pre><code>
public int getBaseModelIndex(int viewIndex) {
    return viewToModelMapping.get(viewIndex).intValue();
}
      </pre></code>
    </div>
  </div>
  <div class="classReport">
    <h2>FindBugsFrame in package edu/umd/cs/findbugs/gui</h2>
    <div class="methodBugReport">
      <ul class="violations">
        <li>
        PARAMETER_TYPE_IN_NAME - ON - NOTIFY
        </li>
      </ul>
      <pre><code>
private void loadBugsFromFile(File file) throws IOException, DocumentException {
    File selectedFile = file;
    Project project = new Project();
    AnalysisRun analysisRun = new AnalysisRun(project, this);
    analysisRun.loadBugsFromFile(selectedFile);
    project.setProjectFileName(file.getName());
    setProject(project);
    synchAnalysisRun(analysisRun);
}
      </pre></code>
    </div>
    <div class="methodBugReport">
      <ul class="violations">
        <li>
        RETURNS_VOID - ON - NOTIFY
        </li>
      </ul>
      <pre><code>
private void newProjectItemActionPerformed(java.awt.event.ActionEvent evt) {
    if (!closeProjectHook(getCurrentProject(), L10N.getLocalString("msg.newproject_txt", "New Project"))) return;
    Project project = new Project();
    setProject(project);
}
      </pre></code>
    </div>
  </div>
  <div class="classReport">
    <h2>BugSet in package edu/umd/cs/findbugs/gui2</h2>
    <div class="methodBugReport">
      <ul class="violations">
        <li>
        SAME_VERB_CALL - ON - INAPPROPRIATE
        </li>
      </ul>
      <pre><code>
public int size() {
    return filteredBugsCached().sizeUnfiltered();
}
      </pre></code>
    </div>
  </div>
  <div class="classReport">
    <h2>BugTreeModel in package edu/umd/cs/findbugs/gui2</h2>
    <div class="methodBugReport">
      <ul class="violations">
        <li>
        RETURNS_VOID - ON - NOTIFY
        </li>
      </ul>
      <pre><code>
public void getOffListenerList() {
    FilterActivity.removeFilterListener(bugTreeFilterListener);
    st.removeColumnModelListener(this);
    tree.removeTreeExpansionListener(this);
}
      </pre></code>
    </div>
  </div>
  <div class="classReport">
    <h2>GUISaveState in package edu/umd/cs/findbugs/gui2</h2>
    <div class="methodBugReport">
      <ul class="violations">
        <li>
        CREATES_OWN_CLASS_OBJECTS - ON - FORBIDDEN
        </li>
      </ul>
      <pre><code>
static void clear() {
    Preferences p = Preferences.userNodeForPackage(GUISaveState.class);
    try {
        p.clear();
    } catch (BackingStoreException e) {
        Debug.println(e);
    }
    instance = new GUISaveState();
}
      </pre></code>
    </div>
  </div>
  <div class="classReport">
    <h2>MainFrame in package edu/umd/cs/findbugs/gui2</h2>
    <div class="methodBugReport">
      <ul class="violations">
        <li>
        RETURNS_REFERENCE - OFF - INAPPROPRIATE
        </li>
        <li>
        RETURNS_VOID - ON - INAPPROPRIATE
        </li>
      </ul>
      <pre><code>
void newProject() {
    clearSourcePane();
    if (curProject == null) redoAnalysis.setEnabled(false); else redoAnalysis.setEnabled(!curProject.getFileList().isEmpty());
    if (newProject) {
        setProjectChanged(true);
        saveFile = null;
        saveMenuItem.setEnabled(false);
        reconfigMenuItem.setEnabled(true);
        newProject = false;
    }
}
      </pre></code>
    </div>
    <div class="methodBugReport">
      <ul class="violations">
        <li>
        NO_PARAMETERS - ON - NOTIFY
        </li>
      </ul>
      <pre><code>
private void setStyleSheets() {
    StyleSheet styleSheet = new StyleSheet();
    styleSheet.addRule("body {font-size: " + Driver.getFontSize() + "pt}");
    styleSheet.addRule("H1 {color: red;  font-size: 120%; font-weight: bold;}");
    styleSheet.addRule("code {font-family: courier; font-size: " + Driver.getFontSize() + "pt}");
    styleSheet.addRule(" a:link { color: #0000FF; } ");
    styleSheet.addRule(" a:visited { color: #800080; } ");
    styleSheet.addRule(" a:active { color: #FF0000; text-decoration: underline; } ");
    htmlEditorKit.setStyleSheet(styleSheet);
    summaryHtmlArea.setEditorKit(htmlEditorKit);
}
      </pre></code>
    </div>
    <div class="methodBugReport">
      <ul class="violations">
        <li>
        PARAMETER_TYPE_IN_NAME - ON - NOTIFY
        </li>
      </ul>
      <pre><code>
/**
	 * @param file
	 * @return
	 */
private void loadProjectFromFile(final File f) {
    Runnable runnable = new Runnable() {

        public void run() {
            final Project project = BugLoader.loadProject(MainFrame.this, f);
            final BugCollection bc = project == null ? null : BugLoader.doAnalysis(project);
            updateProjectAndBugCollection(project, bc, null);
            setProjectAndBugCollectionInSwingThread(project, bc);
        }
    };
    if (EventQueue.isDispatchThread()) new Thread(runnable).start(); else runnable.run();
    return;
}
      </pre></code>
    </div>
  </div>
  <div class="classReport">
    <h2>SortableStringComparator in package edu/umd/cs/findbugs/gui2</h2>
    <div class="methodBugReport">
      <ul class="violations">
        <li>
        CREATES_CUSTOM_OBJECTS - ON - NOTIFY
        </li>
      </ul>
      <pre><code>
public int compare(String one, String two) {
    return mySortable.compare(new SortableValue(mySortable, one), new SortableValue(mySortable, two));
}
      </pre></code>
    </div>
  </div>
  <div class="classReport">
    <h2>Sortables$14 in package edu/umd/cs/findbugs/gui2</h2>
    <div class="methodBugReport">
      <ul class="violations">
        <li>
        CREATES_CUSTOM_OBJECTS - ON - NOTIFY
        </li>
      </ul>
      <pre><code>

      </pre></code>
    </div>
  </div>
  <div class="classReport">
    <h2>ExecutionPlan in package edu/umd/cs/findbugs/plan</h2>
    <div class="methodBugReport">
      <ul class="violations">
        <li>
        RETURN_TYPE_IN_NAME - ON - INAPPROPRIATE
        </li>
      </ul>
      <pre><code>
private DetectorNode addOrCreateDetectorNode(DetectorFactory factory, Map<String, DetectorNode> nodeMap, ConstraintGraph constraintGraph) throws OrderingConstraintException {
    DetectorNode node = nodeMap.get(factory.getFullName());
    if (node == null) {
        node = new DetectorNode(factory);
        nodeMap.put(factory.getFullName(), node);
        constraintGraph.addVertex(node);
    }
    return node;
}
      </pre></code>
    </div>
  </div>
  <div class="classReport">
    <h2>Util in package edu/umd/cs/findbugs/util</h2>
    <div class="methodBugReport">
      <ul class="violations">
        <li>
        RETURN_TYPE_IN_NAME - ON - INAPPROPRIATE
        </li>
      </ul>
      <pre><code>
public static Iterator<Integer> setBitIterator(final BitSet b) {
    return new Iterator<Integer>() {

        int nextBit = b.nextSetBit(0);

        public boolean hasNext() {
            return nextBit >= 0;
        }

        public Integer next() {
            int result = nextBit;
            nextBit = b.nextSetBit(nextBit + 1);
            return result;
        }

        public void remove() {
            throw new UnsupportedOperationException();
        }
    };
}
      </pre></code>
    </div>
  </div>
  <div class="classReport">
    <h2>DismantleBytecode in package edu/umd/cs/findbugs/visitclass</h2>
    <div class="methodBugReport">
      <ul class="violations">
        <li>
        THROWS_EXCEPTIONS - ON - NOTIFY
        </li>
      </ul>
      <pre><code>/** If the current opcode has a reference constant operand, get its name */
public String getNameConstantOperand() {
    if (nameConstantOperand == NOT_AVAILABLE) throw new IllegalStateException("getNameConstantOperand called but value not available");
    return nameConstantOperand;
}
      </pre></code>
    </div>
  </div>

    </div>
  </body>
</html>  
